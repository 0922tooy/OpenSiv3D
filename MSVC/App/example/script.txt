class Vec2Pair
{
	Vec2 left, right;
};

class VisibilityMap
{
	private double m_epsilon = 1e-10;

	private RectF m_region;

	private double m_maxDistance = 0.0;

	private Array<Line> m_lines;

	Array<Vec2Pair> calculateCollidePoints(const Vec2& in eyePos) const
	{
		Array<Vec2Pair> points;

		if (!m_region.stretched(-1).contains(eyePos))
		{
			return points;
		}

		Array<double> angles;
		angles.reserve(m_lines.size());
		{
			for (size_t i = 0; i < m_lines.size(); ++i)
			{
				const Vec2 v = m_lines[i].begin - eyePos;
				angles.push_back(Math::Atan2(v.y, v.x));
			}

			angles.sort();
		}

		points.reserve(angles.size());

		for (size_t i = 0; i < angles.size(); ++i)
		{
			const auto angle = angles[i];
			const double left = angle - m_epsilon;
			const double right = angle + m_epsilon;
			const Line leftRay(eyePos, eyePos + Vec2::Right().rotated(left) * m_maxDistance);
			const Line rightRay(eyePos, eyePos + Vec2::Right().rotated(right) * m_maxDistance);

			Vec2 leftCollidePoint = leftRay.end;
			Vec2 rightCollidePoint = rightRay.end;

			for (size_t k = 0; k < m_lines.size(); ++k)
			{
				const auto line = m_lines[k];

				const auto leftIn = leftRay.intersectsAt(line);
				if (leftIn.has_value())
				{
					if (leftIn.value().distanceFromSq(eyePos) < leftCollidePoint.distanceFromSq(eyePos))
					{
						leftCollidePoint = leftIn.value();
					}
				}

				const auto rightIn = rightRay.intersectsAt(line);
				if (rightIn.has_value())
				{
					if (rightIn.value().distanceFromSq(eyePos) < rightCollidePoint.distanceFromSq(eyePos))
					{
						rightCollidePoint = rightIn.value();
					}
				}		
			}

			Vec2Pair pair;
			pair.left = leftCollidePoint;
			pair.right = rightCollidePoint;
			points.push_back(pair);
		}

		return points;
	}

	VisibilityMap(const RectF& in region = RectF(640, 480))
	{
		m_region = region;
		m_maxDistance = m_region.w + m_region.h;
		add(m_region);
	}

	void add(const Triangle& in s)
	{
		m_lines.push_back(Line(s.p0, s.p1));
		m_lines.push_back(Line(s.p1, s.p2));
		m_lines.push_back(Line(s.p2, s.p0));
	}

	void add(const RectF& in s)
	{
		m_lines.push_back(s.top());
		m_lines.push_back(s.right());
		m_lines.push_back(s.bottom());
		m_lines.push_back(s.left());
	}

	void add(const Quad& in s)
	{
		m_lines.push_back(Line(s.p0, s.p1));
		m_lines.push_back(Line(s.p1, s.p2));
		m_lines.push_back(Line(s.p2, s.p3));
		m_lines.push_back(Line(s.p3, s.p0));
	}

	void add(const Circle& in s, int32 quality = 8)
	{
		quality = Max(quality, 6);	
		const double da = Math::TwoPi / quality;

		for (int32 i = 0; i < quality; ++i)
		{
			m_lines.push_back(Line(OffsetCircular(s.center, s.r, da * i), OffsetCircular(s.center, s.r, da * (i + 1))));
		}
	}

	void add(const Polygon& in s)
	{
		const auto outer = s.outer();

		for (size_t i = 0; i < outer.size(); ++i)
		{
			m_lines.push_back(Line(outer[i], outer[(i + 1) % outer.size()]));
		}	
	}

	const RectF& getRegion() const
	{
		return m_region;
	}

	Array<Triangle> calculateVisibilityTriangles(const Vec2& in eyePos) const
	{
		const auto points = calculateCollidePoints(eyePos);

		Array<Triangle> triangles(points.size());

		for (size_t i = 0; i < triangles.size(); ++i)
		{
			triangles[i].set(eyePos, points[i].right, points[(i + 1) % points.size()].left);
		}

		return triangles;
	}	
};

void Main()
{
	Window::Resize(1280, 720);

	const ColorF objectColor = Palette::Deepskyblue;
	Array<Triangle> triangles = { Triangle(120, 120, 200, 120, 120, 500) };
	Array<RectF> rects = { Rect(600, 40, 40, 260), RectF(440, 300, 440, 40), RectF(1040, 300, 200, 40), Rect(480, 480, 240, 100) };
	Array<Circle> circles = { Circle(1000, 500, 80),  Circle(460, 180, 30), Circle(240, 480, 30), Circle(300, 560, 30) };
	Array<Polygon> polygons = { Shape2D::Star(60, Vec2(940, 180)) };

	for (int32 i = 0; i < 5; ++i)
		rects << Rect(250, 150 + i * 60, 60, 20);

	VisibilityMap map(Rect(40, 40, 1200, 640));

	for (size_t i = 0; i < triangles.size(); ++i)
		map.add(triangles[i]);

	for (size_t i = 0; i < rects.size(); ++i)
		map.add(rects[i]);

	for (size_t i = 0; i < circles.size(); ++i)
		map.add(circles[i]);
		
	for (size_t i = 0; i < polygons.size(); ++i)
		map.add(polygons[i]);			

	while (System::Update())
	{
		for (size_t i = 0; i < triangles.size(); ++i)
			triangles[i].draw(objectColor);

		for (size_t i = 0; i < rects.size(); ++i)
			rects[i].draw(objectColor);

		for (size_t i = 0; i < circles.size(); ++i)
			circles[i].draw(objectColor);
			
		for (size_t i = 0; i < polygons.size(); ++i)
			polygons[i].draw(objectColor);

		map.getRegion().drawFrame(0, 8, objectColor);

		const Vec2 eyePos = Cursor::Pos();
		const auto vTriangles = map.calculateVisibilityTriangles(eyePos);

		for (size_t i = 0; i < vTriangles.size(); ++i)
		{
			vTriangles[i].draw(ColorF(1.0, 0.5));
		}

		Circle(eyePos, 20).draw(Palette::Orange).drawFrame(1, 2);
	}
}
