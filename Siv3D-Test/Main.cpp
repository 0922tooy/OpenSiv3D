
# include <Siv3D.hpp>
# include <unordered_map>
# include "Test/Siv3DTest.hpp"

void Main()
{
	RunTest();

	TimeProfiler tp;

	for (auto k : step(100))
	{
		int n = 0;

		{
			HashMap<String, int> m;

			for (auto i : Range(0, 1000))
			{
				m.insert({ Format(i), i });
			}

			{
				tp.begin(L"hop");

				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];
				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];

				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];
				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];


				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];
				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];


				tp.end();
			}
		}


		{
			std::unordered_map<String, int> m;

			for (auto i : Range(0, 1000))
			{
				m.insert({ Format(i), i });
			}

			{
				tp.begin(L"std");

				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];
				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];

				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];
				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];


				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];
				n += m[L"0"] + m[L"1"] + m[L"2"] + m[L"3"] + m[L"4"] + m[L"5"];
				n += m[L"100"] + m[L"101"] + m[L"102"] + m[L"103"] + m[L"104"] + m[L"105"];

				tp.end();
			}
		}

		Log << n;
	}

	for (auto k : step(100))
	{
		int n = 0;

		{
			HashMap<int, int> m;

			for (auto i : Range(0, 1000))
			{
				m.insert({ i, i });
			}

			{
				tp.begin(L"hop2");

				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];
				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];

				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];
				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];


				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];
				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];


				tp.end();
			}
		}


		{
			std::unordered_map<int, int> m;

			for (auto i : Range(0, 1000))
			{
				m.insert({ i, i });
			}

			{
				tp.begin(L"std2");

				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];
				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];

				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];
				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];


				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];
				n += m[0] + m[1] + m[2] + m[3] + m[4] + m[5];
				n += m[100] + m[101] + m[102] + m[103] + m[104] + m[105];

				tp.end();
			}
		}

		Log << n;
	}

	while (System::Update())
	{

	}
}
